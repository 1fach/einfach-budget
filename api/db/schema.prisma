datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider        = "prisma-client-js"
  binaryTargets   = "native"
  previewFeatures = ["views"]
}

// Don't use unique constaint on primitive type, because the data is
// designed for multiple-user usecase. For example: budget name can't
// be the same for the same user. But there could be two user which have
// different budgets, with the same budget name.
// Solution: Use multi-fields unique constaint with @@unique([...])
//
// On the other hand, unique constraint for reference is allowed.

model User {
  id                  String    @id @default(uuid())
  name                String?
  email               String    @unique
  hashedPassword      String
  salt                String
  resetToken          String?
  resetTokenExpiresAt DateTime?
  budgets             Budget[]

  @@map("user")
}

model Account {
  // It means money account not user account
  id       String @id @default(uuid())
  nickname String

  budget   Budget @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  budgetId String
  payee    Payee  @relation(fields: [payeeId], references: [id], onDelete: Cascade)
  payeeId  String @unique

  transactions   Transaction[]
  accountBalance AccountBalance?

  @@unique([budgetId, nickname]) // don't use the same name of account inside a same budget
  @@index([budgetId])
  @@map("account")
}

model Payee {
  id   String @id @default(uuid())
  name String

  budget   Budget @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  budgetId String

  account      Account?
  transactions Transaction[]

  @@index([budgetId])
  @@map("payee")
}

model Transaction {
  id          String   @id @default(uuid())
  description String
  date        DateTime @default(now()) @db.Date
  outflow     Decimal  @default(0.00) @db.Decimal(12, 2)
  inflow      Decimal  @default(0.00) @db.Decimal(12, 2)
  cleared     Boolean  @default(false)
  createdAt   DateTime @default(now()) @db.Timestamp(2)

  account                    Account                    @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId                  String
  payee                      Payee?                     @relation(fields: [payeeId], references: [id], onDelete: SetNull)
  payeeId                    String?
  monthlyBudgetPerCategory   MonthlyBudgetPerCategory   @relation(fields: [monthlyBudgetPerCategoryId], references: [id], onDelete: Cascade)
  monthlyBudgetPerCategoryId String
  transactionRunningBalance  TransactionRunningBalance?

  @@index([accountId])
  @@map("transaction")
}

model Budget {
  id   String @id @default(uuid())
  name String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  accounts             Account[]
  budgetCategoryGroups BudgetCategoryGroup[]
  payees               Payee[]
  budgetReadyToAssigns BudgetReadyToAssign[]

  @@unique([userId, name]) // a user can't have budget with the same name
  @@index([userId])
  @@map("budget")
}

model MonthlyBudgetPerCategory {
  id       String  @id @default(uuid())
  month    Int
  year     Int
  assigned Decimal @default(0.00) @db.Decimal(12, 2)

  budgetCategory   BudgetCategory @relation(fields: [budgetCategoryId], references: [id], onDelete: Cascade)
  budgetCategoryId String

  transactions            Transaction[]
  monthlyCategoryActivity MonthlyCategoryActivity?

  @@unique([month, year, budgetCategoryId]) // In a month there shouldn't be two same categories
  @@index([budgetCategoryId])
  @@map("monthly_budget_per_category")
}

model BudgetCategoryGroup {
  id        String @id @default(uuid())
  name      String
  sortOrder Int

  budget   Budget @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  budgetId String

  budgetCategories               BudgetCategory[]
  monthlyCategoryGroupActivities MonthlyCategoryGroupActivity[]

  @@unique([name, budgetId])
  @@index([budgetId])
  @@map("budget_category_group")
}

model BudgetCategory {
  id        String @id @default(uuid())
  name      String
  sortOrder Int

  budgetCategoryGroup   BudgetCategoryGroup @relation(fields: [budgetCategoryGroupId], references: [id], onDelete: Cascade)
  budgetCategoryGroupId String

  monthlyBudgetPerCategories MonthlyBudgetPerCategory[]

  @@unique([name, budgetCategoryGroupId])
  @@index([budgetCategoryGroupId])
  @@map("budget_category")
}

view AccountBalance {
  clearedBalance   Decimal
  unclearedBalance Decimal
  workingBalance   Decimal

  account   Account @relation(fields: [accountId], references: [id])
  accountId String  @id

  @@map("account_balance")
}

view BudgetReadyToAssign {
  month         Int
  year          Int
  readyToAssign Decimal

  budget   Budget @relation(fields: [budgetId], references: [id])
  budgetId String

  @@id([budgetId, month, year])
  @@map("budget_ready_to_assign")
}

view MonthlyCategoryActivity {
  activity  Decimal
  available Decimal

  monthlyBudgetPerCategory   MonthlyBudgetPerCategory @relation(fields: [monthlyBudgetPerCategoryId], references: [id])
  monthlyBudgetPerCategoryId String                   @id

  @@map("monthly_category_activity")
}

view MonthlyCategoryGroupActivity {
  month     Int
  year      Int
  assigned  Decimal
  activity  Decimal
  available Decimal

  budgetCategoryGroup   BudgetCategoryGroup @relation(fields: [budgetCategoryGroupId], references: [id])
  budgetCategoryGroupId String

  @@id([month, year, budgetCategoryGroupId])
  @@map("monthly_category_group_activity")
}

view TransactionRunningBalance {
  runningBalance Decimal

  transaction   Transaction @relation(fields: [transactionId], references: [id])
  transactionId String      @id

  @@map("transaction_running_balance")
}
