datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider        = "prisma-client-js"
  binaryTargets   = "native"
  previewFeatures = ["views"]
}

// Don't use unique constaint on primitive type, because the data is
// designed for multiple-user usecase. For example: budget name can't
// be the same for the same user. But there could be two user which have
// different budgets, with the same budget name.
// Solution: Use multi-fields unique constaint with @@unique([...])
//
// On the other hand, unique constraint for reference is allowed.

model User {
  id                  Int       @id @default(autoincrement())
  name                String?
  email               String    @unique
  hashedPassword      String
  salt                String
  resetToken          String?
  resetTokenExpiresAt DateTime?
  budgets             Budget[]
}

model Account {
  // It means money account not user account
  id       Int    @id @default(autoincrement())
  nickname String

  payee    Payee  @relation(fields: [payeeId], references: [id])
  payeeId  Int    @unique // an account should always have an unique payee
  budget   Budget @relation(fields: [budgetId], references: [id])
  budgetId Int

  transactions Transaction[]

  @@unique([budgetId, nickname]) // don't use the same name of account inside a same budget
}

view TotalTransactionsPerAccount {
  accountId        Int     @unique
  clearedBalance   Decimal @default(0.00) @db.Decimal(12, 2)
  unclearedBalance Decimal @default(0.00) @db.Decimal(12, 2)
}

model Payee {
  id   Int    @id @default(autoincrement())
  name String

  account      Account?
  transactions Transaction[]
}

model Transaction {
  id          Int      @id @default(autoincrement())
  description String
  date        DateTime @default(now()) @db.Date
  outflow     Decimal  @default(0.00) @db.Decimal(12, 2)
  inflow      Decimal  @default(0.00) @db.Decimal(12, 2)
  cleared     Boolean  @default(false)

  account                    Account                  @relation(fields: [accountId], references: [id])
  accountId                  Int
  payee                      Payee?                   @relation(fields: [payeeId], references: [id])
  payeeId                    Int?
  monthlyBudgetPerCategory   MonthlyBudgetPerCategory @relation(fields: [monthlyBudgetPerCategoryId], references: [id])
  monthlyBudgetPerCategoryId Int
}

model Budget {
  id   Int    @id @default(autoincrement())
  name String

  user   User @relation(fields: [userId], references: [id])
  userId Int

  accounts       Account[]
  categoryGroups BudgetCategoryGroup[]

  @@unique([userId, name]) // a user can't have budget with the same name
}

model MonthlyBudgetPerCategory {
  id       Int     @id @default(autoincrement())
  month    Int
  year     Int
  assigned Decimal @default(0.00) @db.Decimal(12, 2)

  budgetCategory   BudgetCategory @relation(fields: [budgetCategoryId], references: [id])
  budgetCategoryId Int

  transactions Transaction[]

  @@unique([month, year, budgetCategoryId]) // In a month there shouldn't be two same categories
}

view MonthlyCategoryOutflow {
  monthlyBudgetPerCategoryId Int     @unique
  outflow                    Decimal @default(0.00) @db.Decimal(12, 2)
}

model BudgetCategoryGroup {
  id        Int    @id @default(autoincrement())
  name      String
  sortOrder Int

  budget   Budget @relation(fields: [budgetId], references: [id])
  budgetId Int

  budgetCategory BudgetCategory[]
}

model BudgetCategory {
  id        Int    @id @default(autoincrement())
  name      String
  sortOrder Int

  group   BudgetCategoryGroup @relation(fields: [groupId], references: [id])
  groupId Int

  monthlyBudget MonthlyBudgetPerCategory[]
}
